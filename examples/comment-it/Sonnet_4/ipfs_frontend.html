<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comment-It - Decentralized Comments via IPFS</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e40af;
            --success-color: #059669;
            --warning-color: #d97706;
            --error-color: #dc2626;
            --background-color: #f8fafc;
            --card-background: #ffffff;
            --text-color: #1e293b;
            --text-muted: #64748b;
            --border-color: #e2e8f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            border-radius: 12px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .status-bar {
            background: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--success-color);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .card {
            background: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .card h3 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 1.3rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text-color);
        }

        input, textarea, select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: var(--secondary-color);
            transform: translateY(-1px);
        }

        button:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: var(--text-muted);
        }

        .btn-secondary:hover {
            background: var(--text-color);
        }

        .comment {
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .comment-author {
            font-weight: 600;
            color: var(--primary-color);
        }

        .comment-time {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .comment-content {
            line-height: 1.6;
        }

        .ipfs-info {
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            border: 1px solid #38bdf8;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .ipfs-hash {
            font-family: 'Monaco', 'Consolas', monospace;
            background: rgba(0, 0, 0, 0.1);
            padding: 0.5rem;
            border-radius: 4px;
            word-break: break-all;
            margin: 0.5rem 0;
        }

        .service-discovery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .service-card {
            background: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
        }

        .service-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .service-online {
            color: var(--success-color);
        }

        .service-offline {
            color: var(--error-color);
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: var(--text-muted);
        }

        .spinner {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: var(--error-color);
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .success {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            color: var(--success-color);
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .service-discovery {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Comment-It</h1>
            <p>Decentralized Comments via IPFS & Kaspa Blockchain</p>
        </div>

        <div class="status-bar">
            <div class="status-indicator" id="statusIndicator"></div>
            <div>
                <strong>Status:</strong> <span id="connectionStatus">Connecting to IPFS...</span>
            </div>
        </div>

        <div class="card">
            <h3>üîó Connect Your Kaspa Wallet</h3>
            <div class="form-group">
                <label for="walletAddress">Wallet Address:</label>
                <input type="text" id="walletAddress" placeholder="kaspa:qqxxx..." readonly>
            </div>
            <button id="connectWallet">Connect Wallet</button>
            <button id="disconnectWallet" class="btn-secondary" style="display: none;">Disconnect</button>
        </div>

        <div class="card">
            <h3>üåê Service Discovery</h3>
            <p>Available Comment-It services from the blockchain:</p>
            <div class="service-discovery" id="serviceDiscovery">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Discovering services...</p>
                </div>
            </div>
        </div>

        <div class="card">
            <h3>üìù Post a Comment</h3>
            <div class="form-group">
                <label for="episodeId">Episode ID:</label>
                <input type="text" id="episodeId" placeholder="Enter episode ID">
            </div>
            <div class="form-group">
                <label for="commentText">Your Comment:</label>
                <textarea id="commentText" rows="4" placeholder="Write your comment here..."></textarea>
            </div>
            <button id="postComment" disabled>Post Comment</button>
        </div>

        <div class="card">
            <h3>üí¨ Comments</h3>
            <div class="form-group">
                <label for="loadEpisodeId">Load Episode ID:</label>
                <input type="text" id="loadEpisodeId" placeholder="Enter episode ID to load comments">
                <button id="loadComments" style="margin-top: 0.5rem;">Load Comments</button>
            </div>
            <div id="commentsContainer">
                <div class="loading">
                    <p>Enter an episode ID to load comments</p>
                </div>
            </div>
        </div>

        <div class="card">
            <h3>üì¶ IPFS Information</h3>
            <div class="ipfs-info">
                <strong>Current Frontend Hash:</strong>
                <div class="ipfs-hash" id="currentIpfsHash">Loading...</div>
                <p><strong>Pinned by:</strong> <span id="pinnedBy">Unknown</span></p>
                <p><strong>Gateways:</strong></p>
                <ul id="ipfsGateways"></ul>
            </div>
            <button id="refreshIpfsInfo">Refresh IPFS Info</button>
        </div>

        <div class="card">
            <h3>‚öôÔ∏è Service Management</h3>
            <div class="form-group">
                <label for="serviceEndpoint">Service Endpoint:</label>
                <input type="text" id="serviceEndpoint" placeholder="https://your-service.com">
            </div>
            <div class="form-group">
                <label for="frontendHash">Frontend IPFS Hash (optional):</label>
                <input type="text" id="frontendHash" placeholder="QmXxx...">
            </div>
            <button id="registerService" disabled>Register Service</button>
            <button id="pinContent" class="btn-secondary" disabled>Pin Current Frontend</button>
        </div>
    </div>

    <script>
        // Global state
        let kaspaAuth = null;
        let currentWallet = null;
        let ipfsGateways = [
            'https://ipfs.io/ipfs/',
            'https://gateway.pinata.cloud/ipfs/',
            'https://cloudflare-ipfs.com/ipfs/'
        ];
        let discoveredServices = [];

        // Initialize the application
        async function init() {
            updateStatus('Initializing...', 'warning');
            
            // Get current IPFS hash from URL or meta tag
            const currentHash = getCurrentIpfsHash();
            document.getElementById('currentIpfsHash').textContent = currentHash || 'Unknown';
            
            // Populate IPFS gateways
            const gatewaysList = document.getElementById('ipfsGateways');
            ipfsGateways.forEach(gateway => {
                const li = document.createElement('li');
                li.innerHTML = `<a href="${gateway}${currentHash}" target="_blank">${gateway}</a>`;
                gatewaysList.appendChild(li);
            });
            
            // Initialize Kaspa Auth (mock for demo)
            await initKaspaAuth();
            
            // Discover services
            await discoverServices();
            
            updateStatus('Ready', 'success');
        }

        function getCurrentIpfsHash() {
            // Try to get from URL hash, query param, or meta tag
            const urlHash = window.location.hash.replace('#', '');
            const urlParams = new URLSearchParams(window.location.search);
            const metaHash = document.querySelector('meta[name="ipfs-hash"]')?.content;
            
            return urlHash || urlParams.get('hash') || metaHash || 'QmExampleHashForDemo123456789';
        }

        async function initKaspaAuth() {
            // Mock Kaspa Auth implementation
            // In real implementation, this would connect to actual Kaspa wallet
            kaspaAuth = {
                isConnected: false,
                walletAddress: null,
                
                async connect() {
                    // Simulate wallet connection
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    this.isConnected = true;
                    this.walletAddress = 'kaspa:qq' + Math.random().toString(36).substring(2, 15);
                    return this.walletAddress;
                },
                
                async disconnect() {
                    this.isConnected = false;
                    this.walletAddress = null;
                },
                
                async sign(message) {
                    if (!this.isConnected) throw new Error('Wallet not connected');
                    // Mock signature
                    return 'mock_signature_' + btoa(message);
                }
            };
        }

        async function discoverServices() {
            const container = document.getElementById('serviceDiscovery');
            container.innerHTML = '<div class="loading"><div class="spinner"></div><p>Discovering services...</p></div>';
            
            // Mock service discovery
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            discoveredServices = [
                {
                    wallet: 'kaspa:qqabc123...',
                    endpoints: ['https://comments1.example.com', 'ipfs://QmXxx...'],
                    ipfsHash: 'QmExampleService1',
                    status: 'online',
                    reputation: 95
                },
                {
                    wallet: 'kaspa:qqdef456...',
                    endpoints: ['https://comments2.example.com', 'tor://xyz.onion'],
                    ipfsHash: 'QmExampleService2',
                    status: 'online',
                    reputation: 87
                },
                {
                    wallet: 'kaspa:qqghi789...',
                    endpoints: ['https://comments3.example.com'],
                    ipfsHash: null,
                    status: 'offline',
                    reputation: 72
                }
            ];
            
            renderServices();
        }

        function renderServices() {
            const container = document.getElementById('serviceDiscovery');
            
            if (discoveredServices.length === 0) {
                container.innerHTML = '<p>No services discovered yet.</p>';
                return;
            }
            
            container.innerHTML = discoveredServices.map(service => `
                <div class="service-card">
                    <div class="service-status">
                        <span class="service-${service.status}">‚óè</span>
                        <strong>${service.status.toUpperCase()}</strong>
                    </div>
                    <p><strong>Wallet:</strong> ${service.wallet.substring(0, 20)}...</p>
                    <p><strong>Reputation:</strong> ${service.reputation}/100</p>
                    <p><strong>Endpoints:</strong></p>
                    <ul>
                        ${service.endpoints.map(endpoint => `<li>${endpoint}</li>`).join('')}
                    </ul>
                    ${service.ipfsHash ? `<p><strong>IPFS:</strong> ${service.ipfsHash}</p>` : ''}
                    <button onclick="connectToService('${service.wallet}')" 
                            ${service.status === 'offline' ? 'disabled' : ''}>
                        Connect
                    </button>
                </div>
            `).join('');
        }

        async function connectToService(walletAddress) {
            const service = discoveredServices.find(s => s.wallet === walletAddress);
            if (!service) return;
            
            showMessage(`Connecting to service ${walletAddress.substring(0, 20)}...`, 'info');
            
            // Simulate connection
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            showMessage(`Connected to service successfully!`, 'success');
        }

        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('connectionStatus');
            const indicator = document.getElementById('statusIndicator');
            
            statusElement.textContent = message;
            
            indicator.className = 'status-indicator';
            if (type === 'success') {
                indicator.style.background = 'var(--success-color)';
            } else if (type === 'error') {
                indicator.style.background = 'var(--error-color)';
            } else if (type === 'warning') {
                indicator.style.background = 'var(--warning-color)';
            } else {
                indicator.style.background = 'var(--primary-color)';
            }
        }

        function showMessage(message, type = 'info') {
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'error' ? 'error' : 'success';
            messageDiv.textContent = message;
            
            document.querySelector('.container').insertBefore(
                messageDiv, 
                document.querySelector('.container').firstChild.nextSibling
            );
            
            setTimeout(() => messageDiv.remove(), 5000);
        }

        // Event Listeners
        document.getElementById('connectWallet').addEventListener('click', async () => {
            try {
                updateStatus('Connecting wallet...', 'warning');
                const address = await kaspaAuth.connect();
                
                document.getElementById('walletAddress').value = address;
                document.getElementById('connectWallet').style.display = 'none';
                document.getElementById('disconnectWallet').style.display = 'inline-block';
                document.getElementById('postComment').disabled = false;
                document.getElementById('registerService').disabled = false;
                document.getElementById('pinContent').disabled = false;
                
                updateStatus('Wallet connected', 'success');
                showMessage('Wallet connected successfully!', 'success');
            } catch (error) {
                updateStatus('Connection failed', 'error');
                showMessage('Failed to connect wallet: ' + error.message, 'error');
            }
        });

        document.getElementById('disconnectWallet').addEventListener('click', async () => {
            await kaspaAuth.disconnect();
            
            document.getElementById('walletAddress').value = '';
            document.getElementById('connectWallet').style.display = 'inline-block';
            document.getElementById('disconnectWallet').style.display = 'none';
            document.getElementById('postComment').disabled = true;
            document.getElementById('registerService').disabled = true;
            document.getElementById('pinContent').disabled = true;
            
            updateStatus('Wallet disconnected', 'warning');
        });

        document.getElementById('postComment').addEventListener('click', async () => {
            const episodeId = document.getElementById('episodeId').value;
            const commentText = document.getElementById('commentText').value;
            
            if (!episodeId || !commentText) {
                showMessage('Please enter both episode ID and comment text', 'error');
                return;
            }
            
            try {
                updateStatus('Posting comment...', 'warning');
                
                // Mock comment posting
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                document.getElementById('commentText').value = '';
                showMessage('Comment posted successfully!', 'success');
                updateStatus('Ready', 'success');
                
                // Auto-reload comments for this episode
                document.getElementById('loadEpisodeId').value = episodeId;
                await loadComments();
                
            } catch (error) {
                showMessage('Failed to post comment: ' + error.message, 'error');
                updateStatus('Ready', 'success');
            }
        });

        document.getElementById('loadComments').addEventListener('click', loadComments);

        async function loadComments() {
            const episodeId = document.getElementById('loadEpisodeId').value;
            if (!episodeId) {
                showMessage('Please enter an episode ID', 'error');
                return;
            }
            
            const container = document.getElementById('commentsContainer');
            container.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading comments...</p></div>';
            
            try {
                // Mock comment loading
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                const mockComments = [
                    {
                        author: 'kaspa:qqabc123...',
                        content: 'This is a great episode! Thanks for sharing.',
                        timestamp: new Date(Date.now() - 3600000).toISOString()
                    },
                    {
                        author: 'kaspa:qqdef456...',
                        content: 'I really enjoyed the technical discussion about IPFS integration.',
                        timestamp: new Date(Date.now() - 7200000).toISOString()
                    },
                    {
                        author: 'kaspa:qqghi789...',
                        content: 'Looking forward to the next episode!',
                        timestamp: new Date(Date.now() - 10800000).toISOString()
                    }
                ];
                
                if (mockComments.length === 0) {
                    container.innerHTML = '<p>No comments found for this episode.</p>';
                } else {
                    container.innerHTML = mockComments.map(comment => `
                        <div class="comment">
                            <div class="comment-header">
                                <span class="comment-author">${comment.author.substring(0, 20)}...</span>
                                <span class="comment-time">${new Date(comment.timestamp).toLocaleString()}</span>
                            </div>
                            <div class="comment-content">${comment.content}</div>
                        </div>
                    `).join('');
                }
                
            } catch (error) {
                container.innerHTML = `<div class="error">Failed to load comments: ${error.message}</div>`;
            }
        }

        document.getElementById('refreshIpfsInfo').addEventListener('click', async () => {
            updateStatus('Refreshing IPFS info...', 'warning');
            
            // Mock IPFS info refresh
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            document.getElementById('pinnedBy').textContent = `${discoveredServices.length} services`;
            updateStatus('Ready', 'success');
            showMessage('IPFS information refreshed', 'success');
        });

        document.getElementById('registerService').addEventListener('click', async () => {
            const endpoint = document.getElementById('serviceEndpoint').value;
            if (!endpoint) {
                showMessage('Please enter a service endpoint', 'error');
                return;
            }
            
            try {
                updateStatus('Registering service...', 'warning');
                
                // Mock service registration
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                showMessage('Service registered successfully!', 'success');
                updateStatus('Ready', 'success');
                
                // Refresh service discovery
                await discoverServices();
                
            } catch (error) {
                showMessage('Failed to register service: ' + error.message, 'error');
                updateStatus('Ready', 'success');
            }
        });

        document.getElementById('pinContent').addEventListener('click', async () => {
            try {
                updateStatus('Pinning content...', 'warning');
                
                // Mock content pinning
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                showMessage('Content pinned successfully!', 'success');
                updateStatus('Ready', 'success');
                
            } catch (error) {
                showMessage('Failed to pin content: ' + error.message, 'error');
                updateStatus('Ready', 'success');
            }
        });

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>