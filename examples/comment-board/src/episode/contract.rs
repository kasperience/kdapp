use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use borsh::{BorshDeserialize, BorshSerialize};
use kdapp::pki::PubKey;

/// CommentRoom Episode Contract - Revolutionary decentralized moderation on Kaspa L1
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct CommentRoomContract {
    // Room Identity & Governance
    pub room_creator: PubKey,
    pub room_rules: RoomRules,
    pub created_at: u64,
    pub episode_lifetime: u64,  // Customizable expiration (default 3 days)
    
    // Economic Model - The Heart of Episode Contracts
    pub participation_bond: u64,        // KAS required to comment (e.g., 0.001 KAS)
    pub quality_rewards: HashMap<String, u64>, // Rewards pool for upvoted comments
    pub penalty_pool: u64,              // Accumulated forfeited bonds from violations
    pub total_locked_value: u64,        // Total KAS locked in this contract
    
    // Decentralized Moderation System
    pub moderators: Vec<PubKey>,        // Multi-sig arbiters (3-of-5 typical)
    pub pending_disputes: HashMap<u64, Dispute>, // Active comment disputes
    pub reputation_scores: HashMap<String, i32>, // User reputation (-100 to +100)
    pub voting_power: HashMap<String, u64>,      // Earned voting weight
    
    // Enhanced Comment State with Economics
    pub comments: Vec<EconomicComment>,
    pub comment_bonds: HashMap<u64, CommentBond>, // Locked bonds per comment
    pub voting_results: HashMap<u64, VoteResult>, // Community moderation outcomes
    
    // Room Members with Economic Status
    pub room_members: Vec<String>,
    pub authenticated_users: Vec<String>,
    pub current_challenge: Option<String>,
    
    // Contract Statistics for Twitter Showcase
    pub total_comments: u64,
    pub total_violations: u64,
    pub total_rewards_distributed: u64,
    pub active_disputes: u64,
}

/// Room Rules - Fully Customizable Economic Governance
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct RoomRules {
    // Economic Parameters
    pub min_bond: u64,              // Minimum KAS to comment (prevents spam)
    pub max_bond: u64,              // Maximum bond (for reputation-based discounts)
    pub penalty_multiplier: f64,    // Bond penalty for violations (2.0 = double penalty)
    pub reward_pool_percentage: f64, // % of penalties that go to quality rewards
    
    // Content Rules
    pub max_comment_length: usize,  // Character limit
    pub min_reputation_threshold: i32, // Min reputation to participate
    pub spam_detection_enabled: bool, // Auto-detect spam patterns
    pub forbidden_words: Vec<String>, // Simple word filter for organizer
    
    // Moderation Features
    pub community_moderation: bool, // Enable voting on comments
    pub auto_penalty_enabled: bool, // Automatic penalties for detected violations
    pub dispute_resolution_timeout: u64, // Time limit for dispute resolution
    pub voting_period: u64,         // How long votes remain open
    
    // Advanced Features
    pub reputation_decay_rate: f64, // How fast reputation decays over time
    pub dynamic_bond_pricing: bool, // Adjust bonds based on reputation
    pub quality_bonus_enabled: bool, // Extra rewards for highly upvoted content
}

/// Enhanced Comment with Economic Data
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct EconomicComment {
    pub id: u64,
    pub text: String,
    pub author: String,
    pub timestamp: u64,
    
    // Economic Data
    pub bond_amount: u64,           // KAS locked for this comment
    pub upvotes: u64,               // Community approval
    pub downvotes: u64,             // Community disapproval
    pub quality_score: f64,         // Calculated quality (upvotes/downvotes ratio)
    pub earned_rewards: u64,        // KAS earned from quality bonuses
    
    // Moderation Status
    pub reported_violations: Vec<ViolationReport>,
    pub moderation_status: ModerationStatus,
    pub dispute_id: Option<u64>,    // If under dispute
}

/// Comment Bond - UTXO Lock Information
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct CommentBond {
    pub comment_id: u64,
    pub bonded_amount: u64,
    pub lock_time: u64,            // When bond can be released
    pub release_conditions: ReleaseConditions,
    pub utxo_reference: String,    // Reference to locked UTXO
}

/// UTXO Release Conditions - The Smart Contract Logic
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub enum ReleaseConditions {
    // Normal release after time period with no disputes
    TimeBasedRelease { unlock_time: u64 },
    
    // Community vote outcome
    CommunityVoteOutcome { vote_id: u64, required_consensus: f64 },
    
    // Moderator decision (multi-sig)
    ModeratorDecision { required_signatures: u8, dispute_id: u64 },
    
    // Automatic penalty (spam detection, etc.)
    AutomaticPenalty { violation_type: ViolationType },
}

/// Dispute Resolution System
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct Dispute {
    pub id: u64,
    pub comment_id: u64,
    pub reporter: PubKey,
    pub violation_type: ViolationType,
    pub evidence: String,
    pub created_at: u64,
    pub status: DisputeStatus,
    pub moderator_votes: HashMap<String, ModerationVote>,
    pub community_votes: HashMap<String, CommunityVote>,
}

/// Types of Violations for Automated and Manual Detection
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub enum ViolationType {
    Spam,                    // Automated detection
    OffTopic,               // Community moderation
    Harassment,             // Community + moderator escalation
    InappropriateContent,   // Community + moderator escalation
    Misinformation,         // Moderator decision required
    CopyrightViolation,     // Moderator decision required
}

/// Moderation Status of Comments
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub enum ModerationStatus {
    Active,                 // Normal comment
    UnderReview,           // Being voted on
    Penalized,             // Bond forfeited
    Rewarded,              // Earned quality bonus
    Disputed,              // Escalated to moderators
}

/// Dispute Resolution Status
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub enum DisputeStatus {
    Open,                  // Accepting votes
    UnderModeratorReview,  // Escalated to arbiters
    Resolved,              // Decision made
    Expired,               // Timeout reached
}

/// Violation Report
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct ViolationReport {
    pub reporter: PubKey,
    pub violation_type: ViolationType,
    pub evidence: String,
    pub timestamp: u64,
}

/// Community Vote on Comment Quality/Violations
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct CommunityVote {
    pub voter: PubKey,
    pub decision: VoteDecision,
    pub stake: u64,            // KAS staked on this vote
    pub timestamp: u64,
}

/// Moderator Vote for Dispute Resolution
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct ModerationVote {
    pub moderator: PubKey,
    pub decision: VoteDecision,
    pub reasoning: String,
    pub signature: String,     // Multi-sig component
    pub timestamp: u64,
}

/// Vote Decision Types
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub enum VoteDecision {
    Approve,               // Comment is good
    Penalize,              // Forfeit bond
    Escalate,              // Send to moderators
    Dismiss,               // Invalid report
}

/// Vote Result Summary
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct VoteResult {
    pub comment_id: u64,
    pub total_votes: u64,
    pub approve_votes: u64,
    pub penalize_votes: u64,
    pub escalate_votes: u64,
    pub final_decision: VoteDecision,
    pub resolved_at: u64,
}

impl Default for RoomRules {
    fn default() -> Self {
        RoomRules {
            // Conservative defaults for initial showcase (10x reduced for testing)
            min_bond: 100,               // 0.0001 KAS (very low barrier)
            max_bond: 10000,             // 0.01 KAS (reasonable max)
            penalty_multiplier: 2.0,     // Double penalty for violations
            reward_pool_percentage: 0.8, // 80% of penalties become rewards
            
            // Content rules
            max_comment_length: 500,     // Twitter-like length
            min_reputation_threshold: -50, // Allow some negative reputation
            spam_detection_enabled: true,
            forbidden_words: vec![], // No forbidden words by default
            
            // Moderation settings
            community_moderation: true,
            auto_penalty_enabled: true,
            dispute_resolution_timeout: 172800, // 2 days
            voting_period: 86400,        // 1 day
            
            // Advanced features
            reputation_decay_rate: 0.01, // Slow decay
            dynamic_bond_pricing: true,
            quality_bonus_enabled: true,
        }
    }
}

impl CommentRoomContract {
    /// Create a new episode contract with custom rules
    pub fn new(
        creator: PubKey, 
        rules: RoomRules, 
        moderators: Vec<PubKey>,
        initial_funding: u64,
        episode_lifetime: Option<u64>
    ) -> Self {
        CommentRoomContract {
            room_creator: creator,
            room_rules: rules,
            created_at: 0, // Will be set by PayloadMetadata
            episode_lifetime: episode_lifetime.unwrap_or(259200), // 3 days default
            
            // Economic initialization
            participation_bond: rules.min_bond,
            quality_rewards: HashMap::new(),
            penalty_pool: 0,
            total_locked_value: initial_funding,
            
            // Moderation setup
            moderators,
            pending_disputes: HashMap::new(),
            reputation_scores: HashMap::new(),
            voting_power: HashMap::new(),
            
            // State initialization
            comments: Vec::new(),
            comment_bonds: HashMap::new(),
            voting_results: HashMap::new(),
            room_members: Vec::new(),
            authenticated_users: Vec::new(),
            current_challenge: None,
            
            // Statistics
            total_comments: 0,
            total_violations: 0,
            total_rewards_distributed: 0,
            active_disputes: 0,
        }
    }
    
    /// Calculate dynamic bond price based on user reputation
    pub fn calculate_bond_price(&self, user: &PubKey) -> u64 {
        if !self.room_rules.dynamic_bond_pricing {
            return self.room_rules.min_bond;
        }
        
        let reputation = self.reputation_scores
            .get(&format!("{}", user))
            .copied()
            .unwrap_or(0);
        
        // Better reputation = lower bond requirement
        let reputation_discount = (reputation as f64 / 100.0).max(-0.5).min(0.5);
        let base_bond = self.room_rules.min_bond as f64;
        let discounted_bond = base_bond * (1.0 - reputation_discount);
        
        discounted_bond.max(self.room_rules.min_bond as f64 / 2.0) as u64
    }
    
    /// Check if user meets participation requirements
    pub fn can_participate(&self, user: &PubKey) -> bool {
        let reputation = self.reputation_scores
            .get(&format!("{}", user))
            .copied()
            .unwrap_or(0);
            
        reputation >= self.room_rules.min_reputation_threshold
    }
    
    /// Check if comment contains forbidden words (simple filter)
    pub fn contains_forbidden_words(&self, text: &str) -> Option<String> {
        if self.room_rules.forbidden_words.is_empty() {
            return None;
        }
        
        let text_lower = text.to_lowercase();
        for forbidden_word in &self.room_rules.forbidden_words {
            if text_lower.contains(&forbidden_word.to_lowercase()) {
                return Some(forbidden_word.clone());
            }
        }
        None
    }
    
    /// Get contract statistics for Twitter showcase
    pub fn get_showcase_stats(&self) -> ContractStats {
        ContractStats {
            total_locked_kas: self.total_locked_value,
            active_participants: self.room_members.len() as u64,
            total_comments: self.total_comments,
            average_reputation: self.calculate_average_reputation(),
            penalty_pool_kas: self.penalty_pool,
            rewards_distributed: self.total_rewards_distributed,
            active_disputes: self.active_disputes,
            contract_uptime_hours: self.calculate_uptime_hours(),
        }
    }
    
    fn calculate_average_reputation(&self) -> f64 {
        if self.reputation_scores.is_empty() {
            return 0.0;
        }
        
        let sum: i32 = self.reputation_scores.values().sum();
        sum as f64 / self.reputation_scores.len() as f64
    }
    
    fn calculate_uptime_hours(&self) -> u64 {
        // This would be calculated based on current time vs created_at
        // For now, return placeholder
        24
    }
}

/// Statistics for Twitter/Social Media Showcase
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContractStats {
    pub total_locked_kas: u64,
    pub active_participants: u64,
    pub total_comments: u64,
    pub average_reputation: f64,
    pub penalty_pool_kas: u64,
    pub rewards_distributed: u64,
    pub active_disputes: u64,
    pub contract_uptime_hours: u64,
}